### Create React App

- 페이스북에서 공개한 리액트용 환경 구축 도구

```bash
$ npx create-react-app@latest react-sample --template typescript
```

### JSX -> 브라우저

1. JSX 코드는 브라우저에서 해석될 수 없으므로, 웹팩에 의해 자바스크립트 코드로 변환된다.
2. 이때, JSX로 구현된 컴포넌트가 엘리먼트 객체로 표현 된다.
3. 변환된 자바스크립트 코드를 브라우저가 읽어서 실행하고 화면을 그린다.

### 함수 컴포넌트

- 원래 함수 컴포넌트는 부모로부터 props를 받아 JSX를 반환하기만 하는 컴포넌트였는데,
- 리액트 16.8 부터 Hooks의 등장으로 함수 컴포넌트에서도 내부 상태나 라이프 사이클을 다룰 수 있게 되었다.

### React Hook

- 리액트가 공식적으로 제공하는 훅스 10종류, 이를 조합해 커스텀 훅을 구현할 수 있다.

### useReducer

- 복잡한 상태 전이를 간단하게 기술 할 수 있다.
- 배열이나 객체 등의 여러 데터를 모으는 것을 상태로 다루는 경우에 많이 사용한다.

### useCallback & useMemo

- 자식 컴포넌트에 값이나 함수를 전달할 때 그 값이나 함수가 변하지 않았음에도 부모의 재렌더링으로 인해 자식이 재렌더링되는 것을 방지하기 위해 사용한다.
- memo()로 자식 컴포넌트를 메모이제이션 해도 자식 컴포넌트에 값이나 함수를 전달할 경우 부모의 컴포넌트가 재렌더링 되면 자식도 어쩔 수 없이 다시 렌더링 되게 때문이다.
- useCallback으로 함수를 useMemo로 값을 메모이제이션 하며 이렇게 메모이제이션 할 경우 props나 state값이 바뀌지 않는 이상 자식 컴포넌트는 제렌더링 되지 않는다. 즉, 아래 재렌더링 조건에서 1번, 2번의 경우만 자식 컴포넌트가 재렌더링 되도록 해주어서 최적화 하는 것이다.
- (참고) 재렌더링 조건
  1. props나 내부 state가 업데이트 되었을 때
  2. 컴포넌트 안에서 참조하는 Context값이 업데이트 됬을 때
  3. 부모 컴포넌트가 다시 그려졌을 때
- **useCallback**
  - 함수를 메모이제이션 한다. 의존 배열 안의 값에 다른것이 있을 때는 새로운 함수를 반환한다. 같을 때는 메모이제이션 된 함수를 반환한다. 의존성 배열로 []를 넣어주면 첫 번째 그려질 때 생성된 즉, 메모이제이션 된 함수를 항상 반환.
- **useMemo**
  - 값을 메모이제이션 한다. 첫 번째 인수는 값을 생성하는 함수, 두번 째 인수는 의존 배열을 전달
  - 의존 배열의 값이 이전에 그릴 때와 다른 경우에는 함수를 실행하고, 그 결과를 새로운 값으로 메모에 저장한다.

### useEffect

- 컴포넌트의 렌더링과 직접적인 관계가 없는 처리를(부가 작용) 실행하기 위해 사용하는 훅
- DOM의 수동변경, 로그 출력, 타이머 설정, 데이터 취득 등
- useEffect를 사용하면 props나 state가 업데이트 되고, **렌더링이 완료될 후 처리가 실행된다.**
- 의존 배열을 지정해서, 특정 데이터가 변화할 때만 처리하도록 설정할 수 있다.
- useEffect에서 함수를 반환할 수 있는데 이를 클린업 함수라고 한다. useEffect가 실행되기 직전 또는 언마운트 시 실행된다. 의존 배열이 비어 있는 경우, 컴포넌트가 언마운트될 때만 클린업 함수가 실행된다.

### useLayoutEffect

- useEffect는 컴포넌트가 실행되고 -> DOM이 업데이트 되고, 실제 화면에 결과가 반영된 후에 실행된다.
- 하지만, useLayoutEffect는 DOM이 업데이트된 직후 -> 실제 화면에 결과가 반영되기 전에 실행된다.
- useLayoutEffect로 실행하는 처리는 동기적으로 실행되므로, 무거운 처리를 실행하면 화면 그리기가 지연된다.
